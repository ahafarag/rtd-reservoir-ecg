<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Design Simulation of an RTD Reservoir</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Inter', sans-serif; }
        #container { width: 100vw; height: 100vh; }
        #ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            background-color: rgba(17, 24, 39, 0.8);
            backdrop-filter: blur(5px);
            border: 1px solid rgb(55 65 81);
            color: white;
            padding: 20px;
            border-radius: 12px;
            max-width: 350px;
        }
        .control-btn.active {
            background-color: #0d9488; /* A darker teal */
            border-color: #2dd4bf;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="ui-container">
        <h1 class="text-xl font-bold text-teal-300 mb-2">RTD Reservoir Design Simulator</h1>
        <p class="text-sm text-gray-300 mb-4">An interactive 3D model of the physical device layout. Drag to rotate, scroll to zoom, right-click to pan.</p>
        
        <div class="space-y-4">
             <div class="space-y-2">
                 <label class="block text-sm font-medium text-gray-300">RTD Structure</label>
                 <div class="grid grid-cols-2 gap-2">
                     <button id="btn-double" class="control-btn active w-full bg-teal-700 hover:bg-teal-600 border-2 border-transparent text-white font-bold py-2 px-4 rounded-lg text-xs">Double Barrier</button>
                     <button id="btn-triple" class="control-btn w-full bg-teal-700 hover:bg-teal-600 border-2 border-transparent text-white font-bold py-2 px-4 rounded-lg text-xs">Triple Barrier</button>
                 </div>
             </div>
             <div>
                <label for="rtd-count" class="block text-sm font-medium text-gray-300">Number of RTD Units: <span id="rtd-count-label">5</span></label>
                <input id="rtd-count" type="range" min="1" max="10" value="5" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
             </div>
             <button id="animateBtn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg">Animate Signal Flow</button>
        </div>

        <div class="mt-4 border-t border-gray-700 pt-4">
            <h2 class="font-semibold text-teal-300 mb-2">Legend</h2>
            <div class="space-y-1 text-xs">
                <div class="flex items-center"><div class="w-4 h-4 rounded-full mr-2" style="background-color: #4ade80;"></div><span>Input Signal Line</span></div>
                <div class="flex items-center"><div class="w-4 h-4 rounded-full mr-2" style="background-color: #facc15;"></div><span>Output Signal Lines</span></div>
                <div class="flex items-center"><div class="w-4 h-4 rounded-sm mr-2" style="background-color: #0ea5e9;"></div><span>Emitter/Collector Layers (Doped)</span></div>
                <div class="flex items-center"><div class="w-4 h-4 rounded-sm mr-2" style="background-color: #f97316;"></div><span>Barrier Layers</span></div>
                <div class="flex items-center"><div class="w-4 h-4 rounded-sm mr-2" style="background-color: #a855f7;"></div><span>Quantum Well Layer</span></div>
                <div class="flex items-center"><div class="w-4 h-4 rounded-sm mr-2" style="background-color: #4b5563;"></div><span>Substrate</span></div>
            </div>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls;
        let rtdGroup;
        let currentStructure = 'double';
        let currentCount = 5;

        // --- Initialization ---
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111827); 

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(10, 10, 10);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('container').appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);

            buildScene();

            window.addEventListener('resize', onWindowResize, false);
            
            // Event Listeners for controls
            document.getElementById('rtd-count').addEventListener('input', (event) => {
                currentCount = parseInt(event.target.value);
                document.getElementById('rtd-count-label').textContent = currentCount;
                buildScene();
            });
            document.getElementById('btn-double').addEventListener('click', () => {
                currentStructure = 'double';
                document.getElementById('btn-double').classList.add('active');
                document.getElementById('btn-triple').classList.remove('active');
                buildScene();
            });
             document.getElementById('btn-triple').addEventListener('click', () => {
                currentStructure = 'triple';
                document.getElementById('btn-triple').classList.add('active');
                document.getElementById('btn-double').classList.remove('active');
                buildScene();
            });

            animate();
        }
        
        function buildScene() {
            if (rtdGroup) {
                scene.remove(rtdGroup);
                rtdGroup.traverse(child => { if (child.isMesh) { child.geometry.dispose(); child.material.dispose(); } });
            }

            rtdGroup = new THREE.Group();
            scene.add(rtdGroup);

            const substrateGeo = new THREE.BoxGeometry(15, 0.5, 15);
            const substrateMat = new THREE.MeshStandardMaterial({ color: 0x4b5563 });
            const substrate = new THREE.Mesh(substrateGeo, substrateMat);
            rtdGroup.add(substrate);

            const positions = generatePositions(currentCount);

            positions.forEach(pos => {
                const pillar = createRTDPillar(currentStructure);
                pillar.position.set(pos.x, 2.5, pos.z);
                rtdGroup.add(pillar);
            });
            
            createWiring(positions);
        }


        function generatePositions(count) {
            const positions = [];
            if (count === 1) { positions.push(new THREE.Vector3(0, 0, 0)); return positions; }
            const grid_size = Math.ceil(Math.sqrt(count));
            const spacing = 14 / (grid_size + 1);
            let index = 0;
            for(let i = 0; i < grid_size; i++) {
                for (let j = 0; j < grid_size; j++) {
                    if (index < count) {
                         const x = -7 + spacing * (i + 1);
                         const z = -7 + spacing * (j + 1);
                         positions.push(new THREE.Vector3(x, 0, z));
                         index++;
                    }
                }
            }
            return positions;
        }

        function createRTDPillar(structureType) {
            const pillarGroup = new THREE.Group();
            const pillarRadius = 0.5;
            const totalHeight = 4;
            
            const contactMat = new THREE.MeshStandardMaterial({ color: 0x0ea5e9, roughness: 0.3, metalness: 0.6 });
            const barrierMat = new THREE.MeshStandardMaterial({ color: 0xf97316 });
            const wellMat = new THREE.MeshStandardMaterial({ color: 0xa855f7 });
            
            let yPos = totalHeight / 2;

            function addLayer(height, material) {
                const geo = new THREE.CylinderGeometry(pillarRadius, pillarRadius, height, 32);
                const mesh = new THREE.Mesh(geo, material);
                yPos -= height / 2;
                mesh.position.y = yPos;
                yPos -= height / 2;
                pillarGroup.add(mesh);
            }
            
            const emitterHeight = totalHeight * 0.4;
            addLayer(emitterHeight, contactMat);

            switch(structureType) {
                case 'triple':
                    addLayer(totalHeight * 0.04, barrierMat);
                    addLayer(totalHeight * 0.05, wellMat);
                    addLayer(totalHeight * 0.04, barrierMat);
                    addLayer(totalHeight * 0.05, wellMat);
                    addLayer(totalHeight * 0.04, barrierMat);
                    break;
                case 'double':
                default:
                    addLayer(totalHeight * 0.05, barrierMat);
                    addLayer(totalHeight * 0.1, wellMat);
                    addLayer(totalHeight * 0.05, barrierMat);
                    break;
            }
            
            const collectorHeight = totalHeight - pillarGroup.children.reduce((sum, child) => sum + child.geometry.parameters.height, 0);
            addLayer(collectorHeight, contactMat);

            return pillarGroup;
        }

        function createWiring(rtdPositions) {
            const inputMaterial = new THREE.MeshBasicMaterial({ color: 0x4ade80 });
            const outputMaterial = new THREE.MeshBasicMaterial({ color: 0xfacc15 });
            const tubeRadius = 0.05;

            const inputStart = new THREE.Vector3(0, 6, 10);
            const inputJunction = new THREE.Vector3(0, 6, 0);

            const mainInputCurve = new THREE.CatmullRomCurve3([inputStart, inputJunction]);
            const mainInputGeo = new THREE.TubeGeometry(mainInputCurve, 20, tubeRadius, 8, false);
            const mainInputLine = new THREE.Mesh(mainInputGeo, inputMaterial);
            rtdGroup.add(mainInputLine);

            rtdPositions.forEach(pos => {
                const rtdTop = new THREE.Vector3(pos.x, 4.5, pos.z);
                const branchCurve = new THREE.CatmullRomCurve3([inputJunction, new THREE.Vector3(pos.x, 6, pos.z), rtdTop]);
                const branchGeo = new THREE.TubeGeometry(branchCurve, 20, tubeRadius, 8, false);
                const branchLine = new THREE.Mesh(branchGeo, inputMaterial);
                rtdGroup.add(branchLine);
            });
            
            const outputJunction = new THREE.Vector3(0, -2, 10);
            rtdPositions.forEach(pos => {
                 const rtdBottom = new THREE.Vector3(pos.x, 0.5, pos.z);
                 const outputCurve = new THREE.CatmullRomCurve3([rtdBottom, new THREE.Vector3(pos.x, -1, pos.z), outputJunction]);
                 const outputGeo = new THREE.TubeGeometry(outputCurve, 20, tubeRadius, 8, false);
                 const outputLine = new THREE.Mesh(outputGeo, outputMaterial);
                 rtdGroup.add(outputLine);
            });
        }
        
        let animationTime = 0;
        let isAnimating = false;

        function animateSignal() {
            if (!isAnimating || !rtdGroup) return;
            animationTime += 0.05;
            
            rtdGroup.children.forEach(child => {
                if (child.isMesh && child.geometry.type === 'TubeGeometry') {
                     if(child.material.color.getHex() === 0x4ade80) { // Input lines
                         child.material.color.setHSL( (animationTime * 0.5) % 1, 0.8, 0.6);
                     } else if (child.material.color.getHex() === 0xfacc15) { // Output lines
                         child.material.color.setHSL( (animationTime * 0.3) % 1, 1.0, 0.6);
                     }
                }
            });
        }
        
        document.getElementById('animateBtn').addEventListener('click', () => {
            isAnimating = !isAnimating;
            if(!isAnimating && rtdGroup){
                 buildScene();
            }
        });

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            animateSignal();
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
    </script>
</body>
</html>
